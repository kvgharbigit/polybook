<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <script src="./bergamot-translator-worker.js"></script>
  <script>
    let ready = false;
    let service = null;
    let models = {};

    function post(obj){
      window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify(obj));
    }

    async function init(){
      if (ready) return;
      try {
        console.log('Initializing Bergamot WASM...');
        
        // Initialize Bergamot translator service
        // The worker.js provides a translation service factory
        const BergamotTranslatorService = await TranslationServiceFactory.createService({
          // Use relative paths for models
          modelsPath: './models/',
          // All 14 available language pairs
          models: {
            'en-es': { model: './models/enes/model.enes.intgemm.alphas.bin', vocab: './models/enes/vocab.enes.spm', lex: './models/enes/lex.50.50.enes.s2t.bin' },
            'en-fr': { model: './models/enfr/model.enfr.intgemm.alphas.bin', vocab: './models/enfr/vocab.enfr.spm', lex: './models/enfr/lex.50.50.enfr.s2t.bin' },
            'en-de': { model: './models/ende/model.ende.intgemm.alphas.bin', vocab: './models/ende/vocab.ende.spm', lex: './models/ende/lex.50.50.ende.s2t.bin' },
            'en-it': { model: './models/enit/model.enit.intgemm.alphas.bin', vocab: './models/enit/vocab.enit.spm', lex: './models/enit/lex.50.50.enit.s2t.bin' },
            'en-pt': { model: './models/enpt/model.enpt.intgemm.alphas.bin', vocab: './models/enpt/vocab.enpt.spm', lex: './models/enpt/lex.50.50.enpt.s2t.bin' },
            'en-ru': { model: './models/enru/model.enru.intgemm.alphas.bin', vocab: './models/enru/vocab.enru.spm', lex: './models/enru/lex.50.50.enru.s2t.bin' },
            'en-hi': { model: './models/enhi/model.enhi.intgemm.alphas.bin', vocab: './models/enhi/vocab.enhi.spm', lex: './models/enhi/lex.50.50.enhi.s2t.bin' },
            'es-en': { model: './models/esen/model.esen.intgemm.alphas.bin', vocab: './models/esen/vocab.esen.spm', lex: './models/esen/lex.50.50.esen.s2t.bin' },
            'fr-en': { model: './models/fren/model.fren.intgemm.alphas.bin', vocab: './models/fren/vocab.fren.spm', lex: './models/fren/lex.50.50.fren.s2t.bin' },
            'de-en': { model: './models/deen/model.deen.intgemm.alphas.bin', vocab: './models/deen/vocab.deen.spm', lex: './models/deen/lex.50.50.deen.s2t.bin' },
            'it-en': { model: './models/iten/model.iten.intgemm.alphas.bin', vocab: './models/iten/vocab.iten.spm', lex: './models/iten/lex.50.50.iten.s2t.bin' },
            'pt-en': { model: './models/pten/model.pten.intgemm.alphas.bin', vocab: './models/pten/vocab.pten.spm', lex: './models/pten/lex.50.50.pten.s2t.bin' },
            'ru-en': { model: './models/ruen/model.ruen.intgemm.alphas.bin', vocab: './models/ruen/vocab.ruen.spm', lex: './models/ruen/lex.50.50.ruen.s2t.bin' },
            'hi-en': { model: './models/hien/model.hien.intgemm.alphas.bin', vocab: './models/hien/vocab.hien.spm', lex: './models/hien/lex.50.50.hien.s2t.bin' }
          }
        });
        
        service = BergamotTranslatorService;
        ready = true;
        
        post({ type: 'ready' });
        console.log('Bergamot initialization complete');
        
      } catch (e) {
        console.error('Bergamot initialization failed:', e);
        // Fall back to mock translation for testing
        ready = 'mock';
        post({ type: 'ready', mock: true });
      }
    }

    async function mockTranslate(text, from, to) {
      // Enhanced mock translation supporting all 8 languages
      const translations = {
        'en-es': { 'hello': 'hola', 'world': 'mundo', 'good': 'bueno', 'morning': 'mañana', 'thank you': 'gracias' },
        'en-fr': { 'hello': 'bonjour', 'world': 'monde', 'good': 'bon', 'morning': 'matin', 'thank you': 'merci' },
        'en-de': { 'hello': 'hallo', 'world': 'welt', 'good': 'gut', 'morning': 'morgen', 'thank you': 'danke' },
        'en-it': { 'hello': 'ciao', 'world': 'mondo', 'good': 'buono', 'morning': 'mattina', 'thank you': 'grazie' },
        'en-pt': { 'hello': 'olá', 'world': 'mundo', 'good': 'bom', 'morning': 'manhã', 'thank you': 'obrigado' },
        'en-ru': { 'hello': 'привет', 'world': 'мир', 'good': 'хороший', 'morning': 'утро', 'thank you': 'спасибо' },
        'en-hi': { 'hello': 'नमस्ते', 'world': 'दुनिया', 'good': 'अच्छा', 'morning': 'सुबह', 'thank you': 'धन्यवाद' },
        'es-en': { 'hola': 'hello', 'mundo': 'world', 'bueno': 'good', 'mañana': 'morning', 'gracias': 'thank you' },
        'fr-en': { 'bonjour': 'hello', 'monde': 'world', 'bon': 'good', 'matin': 'morning', 'merci': 'thank you' },
        'de-en': { 'hallo': 'hello', 'welt': 'world', 'gut': 'good', 'morgen': 'morning', 'danke': 'thank you' },
        'it-en': { 'ciao': 'hello', 'mondo': 'world', 'buono': 'good', 'mattina': 'morning', 'grazie': 'thank you' },
        'pt-en': { 'olá': 'hello', 'mundo': 'world', 'bom': 'good', 'manhã': 'morning', 'obrigado': 'thank you' },
        'ru-en': { 'привет': 'hello', 'мир': 'world', 'хороший': 'good', 'утро': 'morning', 'спасибо': 'thank you' },
        'hi-en': { 'नमस्ते': 'hello', 'दुनिया': 'world', 'अच्छा': 'good', 'सुबह': 'morning', 'धन्यवाद': 'thank you' }
      };

      const pairKey = `${from}-${to}`;
      const pairTranslations = translations[pairKey] || {};

      let result = text.toLowerCase();
      Object.entries(pairTranslations).forEach(([source, target]) => {
        const regex = new RegExp(`\\b${source}\\b`, 'gi');
        result = result.replace(regex, target);
      });

      // If no translations applied and it's an unsupported pair, indicate via English
      if (result === text.toLowerCase() && !translations[pairKey]) {
        if (to === 'en') {
          result = `[${from.toUpperCase()}→EN] ${text}`;
        } else {
          result = `[EN→${to.toUpperCase()}] ${text}`;
        }
      }

      return {
        text: result,
        qualityHint: -2.5 // Mock quality hint
      };
    }

    async function translate({id, text, from, to}){
      try {
        if (!ready) await init();
        
        let result;
        
        if (ready === 'mock' || !service) {
          // Use mock translation
          result = await mockTranslate(text, from, to);
          console.log(`Mock translation: "${text}" → "${result.text}"`);
        } else {
          // Use real Bergamot translation
          try {
            const translationResult = await service.translate(text, {
              from: from,
              to: to
            });
            
            result = {
              text: translationResult.text,
              qualityHint: translationResult.quality || null
            };
            
            console.log(`Bergamot translation: "${text}" → "${result.text}"`);
          } catch (bergamotError) {
            console.warn('Bergamot translation failed, falling back to mock:', bergamotError);
            result = await mockTranslate(text, from, to);
          }
        }
        
        post({ type: 'result', id, text: result.text, qualityHint: result.qualityHint });
        
      } catch (e) {
        console.error('Translation error:', e);
        post({ type: 'error', id, error: String(e?.message || e) });
      }
    }

    window.addEventListener('message', (ev) => {
      try {
        const msg = JSON.parse(ev.data || '{}');
        if (msg.type === 'translate') translate(msg);
        if (msg.type === 'warmup') init();
      } catch {}
    });

    // Warm start
    init();
  </script>
</head>
<body></body>
</html>